{
    "docs": [
        {
            "location": "/",
            "text": "Tako\n\n\nTako securely downloads and updates binary files such as container images. It\nis intended as a lightweight delivery mechanism for signed versioned images.\nThrough version bounds Tako enables automatic security updates while avoiding\nbreaking changes. Ed25519 signatures ensure that images come from a trusted\nsource.\n\n\nTako is a short-lived process that downloads images specified in its\nconfiguration and then exits. Optionally Tako restarts configured systemd units\nwhen it downloads a newer version of an image. Tako runs on two occasions:\n\n\n\n\nPeriodically, triggered by a systemd timer. Tako checks for new compatible\n   versions of a configured image. If one exists, Tako downloads it and restarts\n   the systemd unit that uses the image.\n\n\nAs a dependency of the systemd unit that uses the image, to provision a clean\n   system with an initial image.\n\n\n\n\nTako is a single binary with minimal dependencies (libc and libcurl only),\nbecause Tako is used to bootstrap more complex applications. Installing Tako is\nas easy as copying over the binary.\n\n\nUser Guide\n\n\n\n\nDownloading Images\n\n\nDistributing Images\n\n\nConfiguration\n\n\nVersions\n\n\n\n\nReference\n\n\n\n\ntako fetch\n\n\ntako store\n\n\ntako gen-key\n\n\n\n\nInternals\n\n\n\n\nManifest Format",
            "title": "Overview"
        },
        {
            "location": "/#tako",
            "text": "Tako securely downloads and updates binary files such as container images. It\nis intended as a lightweight delivery mechanism for signed versioned images.\nThrough version bounds Tako enables automatic security updates while avoiding\nbreaking changes. Ed25519 signatures ensure that images come from a trusted\nsource.  Tako is a short-lived process that downloads images specified in its\nconfiguration and then exits. Optionally Tako restarts configured systemd units\nwhen it downloads a newer version of an image. Tako runs on two occasions:   Periodically, triggered by a systemd timer. Tako checks for new compatible\n   versions of a configured image. If one exists, Tako downloads it and restarts\n   the systemd unit that uses the image.  As a dependency of the systemd unit that uses the image, to provision a clean\n   system with an initial image.   Tako is a single binary with minimal dependencies (libc and libcurl only),\nbecause Tako is used to bootstrap more complex applications. Installing Tako is\nas easy as copying over the binary.",
            "title": "Tako"
        },
        {
            "location": "/#user-guide",
            "text": "Downloading Images  Distributing Images  Configuration  Versions",
            "title": "User Guide"
        },
        {
            "location": "/#reference",
            "text": "tako fetch  tako store  tako gen-key",
            "title": "Reference"
        },
        {
            "location": "/#internals",
            "text": "Manifest Format",
            "title": "Internals"
        },
        {
            "location": "/downloading-images/",
            "text": "Downloading Images\n\n\nTo download images with Tako, the image distributor should have provided you\nwith two things:\n\n\n\n\nA remote url, such as \nhttps://images.example.com/app-foo\n.\n\n\nA public key, such as \nl0D28J2fiIXvWPbeZP7wkaq+dB55Gl2ysigl9mQH29k=\n.\n\n\n\n\nThe next step is to create a \nconfiguration file\n to tell Tako\nwhat to fetch from that remote, and where to store it. For example, write the\nfollowing to \nexample.tako\n:\n\n\nOrigin=https://images.example.com/app-foo\nPublicKey=l0D28J2fiIXvWPbeZP7wkaq+dB55Gl2ysigl9mQH29k=\nDestination=/tmp/app-foo\nVersion=*\n\n\n\nDownload the latest available image with\n\ntako fetch example.tako\n. Now \n/tmp/app-foo/latest\n is a\nsymlink to the latest image, which itself is stored as a readonly file in\n\n/tmp/app-foo/store\n.\n\n\nLocal Store\n\n\nTako downloads images into a destination directory. It creates the following\nfiles there:\n\n\nstore/<hexdigest>  # Readonly raw image files.\nmanifest           # A copy of the manifest served by the origin.\nlatest             # Symlink to the latest image.\n\n\n\nThe store keeps older versions to allow quick rollbacks. In the future Tako\nwill be able to prune older versions if the store exceeds a certain size.\n\n\n\nAutomating Updates\n\n\nTo use Tako to keep the image up to date, run Tako periodically, for example\nusing a \nsystemd timer\n. Using \nRandomizedDelaySec=\n is\nrecommended to avoid overloading the remote server.\n\n\n\n\n\nInitial Provisioning\n\n\nSee \ntako fetch --init\n.",
            "title": "Downloading Images"
        },
        {
            "location": "/downloading-images/#downloading-images",
            "text": "To download images with Tako, the image distributor should have provided you\nwith two things:   A remote url, such as  https://images.example.com/app-foo .  A public key, such as  l0D28J2fiIXvWPbeZP7wkaq+dB55Gl2ysigl9mQH29k= .   The next step is to create a  configuration file  to tell Tako\nwhat to fetch from that remote, and where to store it. For example, write the\nfollowing to  example.tako :  Origin=https://images.example.com/app-foo\nPublicKey=l0D28J2fiIXvWPbeZP7wkaq+dB55Gl2ysigl9mQH29k=\nDestination=/tmp/app-foo\nVersion=*  Download the latest available image with tako fetch example.tako . Now  /tmp/app-foo/latest  is a\nsymlink to the latest image, which itself is stored as a readonly file in /tmp/app-foo/store .",
            "title": "Downloading Images"
        },
        {
            "location": "/downloading-images/#local-store",
            "text": "Tako downloads images into a destination directory. It creates the following\nfiles there:  store/<hexdigest>  # Readonly raw image files.\nmanifest           # A copy of the manifest served by the origin.\nlatest             # Symlink to the latest image.  The store keeps older versions to allow quick rollbacks. In the future Tako\nwill be able to prune older versions if the store exceeds a certain size.",
            "title": "Local Store"
        },
        {
            "location": "/downloading-images/#automating-updates",
            "text": "To use Tako to keep the image up to date, run Tako periodically, for example\nusing a  systemd timer . Using  RandomizedDelaySec=  is\nrecommended to avoid overloading the remote server.",
            "title": "Automating Updates"
        },
        {
            "location": "/downloading-images/#initial-provisioning",
            "text": "See  tako fetch --init .",
            "title": "Initial Provisioning"
        },
        {
            "location": "/distributing-images/",
            "text": "Distributing Images\n\n\nA Tako server is a regular http server, with a particular directory layout.\nThe origin uri points to a directory that contains the manifest file and the\nimage store.\n\n\n\n\nmanifest\n is a file that lists all available versions and their SHA256\n   digests. The manifest is signed. See \nManifest Format\n\n   for more information about the manifest format.\n\n\nstore\n is a directory that contains all images. Files are named after their\n   digest.\n\n\n\n\nImages can be added to the directory with \ntako store\n. The\nmost convenient way to maintain the server directory is to have a local copy\nthat Tako can act on, and to sync that to a server.\n\n\nImmutable Images\n\n\nTako is designed as an append-only system where images are immutable. Changing\nan image is not possible: publish it as a new version instead. The Tako client\n\ntako fetch\n stores a copy of the manifest locally, and when it\ndownloads a new version of the manifest, it must be a superset of the local\nmanifest. If the hash of a particular version has changed in the remote\nmanifest, or if a version was removed, the client rejects the new manifest, even\nif it has a valid signature.\n\n\nIn some occasions, it might be necessary to remove a previously published image.\nTo do so, simply stop serving the image by removing it from the \nstore\n\ndirectory. The manifest will still list the image. If a client selects that\nparticular image as a candidate to download, the \ntako fetch\n\nwill fail. This is generally not an issue if a newer compatible version is\navailable. If this is not the case, you can configure the server to serve \u201c410\nGone\u201d on the url of the removed image. If \ntako fetch\n\nencounters a 410 it will not fail, but instead select an earlier compatible\nversion and try again.",
            "title": "Distributing Images"
        },
        {
            "location": "/distributing-images/#distributing-images",
            "text": "A Tako server is a regular http server, with a particular directory layout.\nThe origin uri points to a directory that contains the manifest file and the\nimage store.   manifest  is a file that lists all available versions and their SHA256\n   digests. The manifest is signed. See  Manifest Format \n   for more information about the manifest format.  store  is a directory that contains all images. Files are named after their\n   digest.   Images can be added to the directory with  tako store . The\nmost convenient way to maintain the server directory is to have a local copy\nthat Tako can act on, and to sync that to a server.",
            "title": "Distributing Images"
        },
        {
            "location": "/distributing-images/#immutable-images",
            "text": "Tako is designed as an append-only system where images are immutable. Changing\nan image is not possible: publish it as a new version instead. The Tako client tako fetch  stores a copy of the manifest locally, and when it\ndownloads a new version of the manifest, it must be a superset of the local\nmanifest. If the hash of a particular version has changed in the remote\nmanifest, or if a version was removed, the client rejects the new manifest, even\nif it has a valid signature.  In some occasions, it might be necessary to remove a previously published image.\nTo do so, simply stop serving the image by removing it from the  store \ndirectory. The manifest will still list the image. If a client selects that\nparticular image as a candidate to download, the  tako fetch \nwill fail. This is generally not an issue if a newer compatible version is\navailable. If this is not the case, you can configure the server to serve \u201c410\nGone\u201d on the url of the removed image. If  tako fetch \nencounters a 410 it will not fail, but instead select an earlier compatible\nversion and try again.",
            "title": "Immutable Images"
        },
        {
            "location": "/configuration/",
            "text": "Configuration\n\n\nTako determines what to fetch and where to store images from a config file, one\nper image. Config files follow the same syntax as systemd unit files.\n\n\nExample\n\n\nOrigin=https://images.example.com/app-foo\nPublicKey=8+r5DKNN/cwI+h0oHxMtgdyND3S/5xDLHQu0hFUmq+g=\nDestination=/var/lib/images/app-foo\nVersion=1.*\n\n# Restart app-foo after a new image has been fetched.\nRestartUnit=app-foo.service\n\n\n\nOptions\n\n\nThe following options are available. Unless noted otherwise, all options must be\nspecified exactly once.\n\n\nOrigin=\n\n\nRemote uri to fetch the manifest and images from. Usually an https url, but\nanything supported by Curl will do, such as a \nfile://\n or \nssh://\n uri. The uri\nmust point to a directory that contains a manifest file. A trailing slash is\nallowed, but not required.\n\n\nPublicKey=\n\n\nPublic key used to verify image interity and authenthicity. The public key\nshould be announced by the distributor of the image. Distributors can generate\na key pair with \ntako gen-key\n.\n\n\nDestination=\n\n\nDirectory where images will be stored. This directory must exist. Tako will\ncreate a \nstore\n subdirectory to hold images, a \nmanifest\n file which is a copy\nof the remote manifest, and a \nlatest\n symlink that points to the latest\ncompatible image in the store. A trailing slash is allowed, but not required.\n\n\nVersion=\n\n\nA version pattern that indicates which version range is compatible. Tako will\nfetch the latest (highest numbered) compatible version. The version pattern\ncan be a fixed version, a wildcard pattern, or a bounds pattern. See\n\nVersions\n for more information.\n\n\nRestart=\n\n\nA systemd unit to restart in case a newer image has been fetched. The format is\nthe same as that of \nRequires=\n in systemd units. This\noption may be specified more than once, or multiple space-separated units may be\nspecified in one option. This option is not required: if it is not set, no unit\nwill be restarted.\n\n\nComments\n\n\nLike systemd unit files, lines starting with \n#\n or \n;\n are ignored. Empty lines\nare ignored as well.",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#configuration",
            "text": "Tako determines what to fetch and where to store images from a config file, one\nper image. Config files follow the same syntax as systemd unit files.",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#example",
            "text": "Origin=https://images.example.com/app-foo\nPublicKey=8+r5DKNN/cwI+h0oHxMtgdyND3S/5xDLHQu0hFUmq+g=\nDestination=/var/lib/images/app-foo\nVersion=1.*\n\n# Restart app-foo after a new image has been fetched.\nRestartUnit=app-foo.service",
            "title": "Example"
        },
        {
            "location": "/configuration/#options",
            "text": "The following options are available. Unless noted otherwise, all options must be\nspecified exactly once.",
            "title": "Options"
        },
        {
            "location": "/configuration/#origin",
            "text": "Remote uri to fetch the manifest and images from. Usually an https url, but\nanything supported by Curl will do, such as a  file://  or  ssh://  uri. The uri\nmust point to a directory that contains a manifest file. A trailing slash is\nallowed, but not required.",
            "title": "Origin="
        },
        {
            "location": "/configuration/#publickey",
            "text": "Public key used to verify image interity and authenthicity. The public key\nshould be announced by the distributor of the image. Distributors can generate\na key pair with  tako gen-key .",
            "title": "PublicKey="
        },
        {
            "location": "/configuration/#destination",
            "text": "Directory where images will be stored. This directory must exist. Tako will\ncreate a  store  subdirectory to hold images, a  manifest  file which is a copy\nof the remote manifest, and a  latest  symlink that points to the latest\ncompatible image in the store. A trailing slash is allowed, but not required.",
            "title": "Destination="
        },
        {
            "location": "/configuration/#version",
            "text": "A version pattern that indicates which version range is compatible. Tako will\nfetch the latest (highest numbered) compatible version. The version pattern\ncan be a fixed version, a wildcard pattern, or a bounds pattern. See Versions  for more information.",
            "title": "Version="
        },
        {
            "location": "/configuration/#restart",
            "text": "A systemd unit to restart in case a newer image has been fetched. The format is\nthe same as that of  Requires=  in systemd units. This\noption may be specified more than once, or multiple space-separated units may be\nspecified in one option. This option is not required: if it is not set, no unit\nwill be restarted.",
            "title": "Restart="
        },
        {
            "location": "/configuration/#comments",
            "text": "Like systemd unit files, lines starting with  #  or  ;  are ignored. Empty lines\nare ignored as well.",
            "title": "Comments"
        },
        {
            "location": "/versions/",
            "text": "Versions\n\n\nTako does not enforce any particular versioning scheme. Instead it implements a\nsimple version parser and constraint resolver that is compatible with most\nversioning schemes, such as \nSemantic Versioning\n.\n\n\nPatterns\n\n\nCompatible versions are selected by matching versions against a pattern.\nA pattern is either a \nwildcard pattern\n or a \nbounds pattern\n.\n\n\n\n\nA wildcard pattern is a version that may end in \n*\n.\n\n\nA bounds pattern specifies an inclusive lower bound and an exclusive upper\n   bound separated by \n<= v <\n.\n\n\n\n\nSome examples:\n\n\n\n\n*\n matches any version.\n\n\n1.*\n matches \n1.0\n, \n1.1\n, \n1.2\n, etc., but not \n2.0\n, or \n0.1\n.\n   It does match \n1\n and \n1.0.0\n, which are both equivalent to \n1.0\n.\n\n\n1.13.7\n matches \n1.13.7\n. It also matches \n1.13.7.0\n, \n1.13.7.0.0\n,\n   etc., which are equivalent to \n1.13.7\n. Such a pattern can be used for\n   version pinning.\n\n\n1.0 <= v < 2.0\n is the same as \n1.*\n.\n\n\n2.3 <= v < 3.0\n matches versions that are \nsemver-compatible\n\n   with 2.3.\n\n\n\n\nSyntax\n\n\nVersions consist of \nparts\n separated by \nseparators\n.\n\n\n\n\nA part is either numeric or a string. A numeric part is an unsigned integer.\n\n\nA separator is one of \n.\n, \n-\n, and \n_\n.\n\n\n\n\nVersions map to a list of parts. Some examples:\n\n\n\n\n1.0.0\n \u21d2 \n[1, 0, 0]\n\n\n1.0.0-beta\n \u21d2 \n[1, 0, 0, \"beta\"]\n\n\n1.0.0-beta-25856-ge63d979e22\n \u21d2 \n[1, 1, 0, \"beta\", 25856, \"ge63d979e22\"]\n\n\n1.0.0-beta.2\n \u21d2 \n[1, 0, 0, \"beta\", 2]\n\n\n1.1.0.h-1\n \u21d2 \n[1, 1, 0, \"h\", 1]\n\n\n66.0.3359.117-1\n \u21d2 \n[66, 0, 3359, 117, 1]\n\n\n1.2a\n \u21d2 \n[1, \"2a\"]\n\n\n\n\nOrdering\n\n\nVersions are ordered conventionally. They are compared part by part. String\nparts order before numeric parts, and string parts order lexicographically.\nVersions are implicitly padded with zero parts: when two versions with a\ndifferent number of parts are compared, the shorter one is padded with zeros.\nIt is generally a bad idea to use a versioning scheme with a variable number\nof parts though. Separator characters do not affect ordering.\n\n\nSome examples:\n\n\n\n\n1.0.0\n < \n2.0.0\n\n\n1.0.0\n < \n1.1.0\n\n\n1.0.0\n < \n1.0.1\n\n\n1\n = \n1.0\n\n\n1-0\n = \n1.0\n\n\n1.a\n < \n1.0\n (string parts order before numeric parts)\n\n\n1.0.0.a\n < \n1.0.0\n (string parts order before the implicit zero part)\n\n\n1.0.a\n < \n1.0.b\n\n\n1.0.0-beta.1\n < \n1.0.0\n (string parts order before the implicit zero part)\n\n\n1.0.0-beta\n < \n1.0.0-beta.1\n (implicit zero orders before 1)\n\n\n1.0.0-beta.1\n < \n1.0.0-beta.2\n\n\n1.2a\n < \n1.1\n (string parts order before numeric parts)\n\n\n\n\nSome of these might be counterintuitive. Unfortunately we cannot have both of\nthe following be true without complicating the comparison rules.\n\n\n\n\n1.0-beta.1\n < \n1.0\n.\n\n\n1.0\n < \n1.0.a\n\n\n\n\nTako implements the first choice, and hence \n1.0.a\n < \n1.0\n. To avoid\nconfusion, use a versioning scheme that has a fixed number of parts.",
            "title": "Versions"
        },
        {
            "location": "/versions/#versions",
            "text": "Tako does not enforce any particular versioning scheme. Instead it implements a\nsimple version parser and constraint resolver that is compatible with most\nversioning schemes, such as  Semantic Versioning .",
            "title": "Versions"
        },
        {
            "location": "/versions/#patterns",
            "text": "Compatible versions are selected by matching versions against a pattern.\nA pattern is either a  wildcard pattern  or a  bounds pattern .   A wildcard pattern is a version that may end in  * .  A bounds pattern specifies an inclusive lower bound and an exclusive upper\n   bound separated by  <= v < .   Some examples:   *  matches any version.  1.*  matches  1.0 ,  1.1 ,  1.2 , etc., but not  2.0 , or  0.1 .\n   It does match  1  and  1.0.0 , which are both equivalent to  1.0 .  1.13.7  matches  1.13.7 . It also matches  1.13.7.0 ,  1.13.7.0.0 ,\n   etc., which are equivalent to  1.13.7 . Such a pattern can be used for\n   version pinning.  1.0 <= v < 2.0  is the same as  1.* .  2.3 <= v < 3.0  matches versions that are  semver-compatible \n   with 2.3.",
            "title": "Patterns"
        },
        {
            "location": "/versions/#syntax",
            "text": "Versions consist of  parts  separated by  separators .   A part is either numeric or a string. A numeric part is an unsigned integer.  A separator is one of  . ,  - , and  _ .   Versions map to a list of parts. Some examples:   1.0.0  \u21d2  [1, 0, 0]  1.0.0-beta  \u21d2  [1, 0, 0, \"beta\"]  1.0.0-beta-25856-ge63d979e22  \u21d2  [1, 1, 0, \"beta\", 25856, \"ge63d979e22\"]  1.0.0-beta.2  \u21d2  [1, 0, 0, \"beta\", 2]  1.1.0.h-1  \u21d2  [1, 1, 0, \"h\", 1]  66.0.3359.117-1  \u21d2  [66, 0, 3359, 117, 1]  1.2a  \u21d2  [1, \"2a\"]",
            "title": "Syntax"
        },
        {
            "location": "/versions/#ordering",
            "text": "Versions are ordered conventionally. They are compared part by part. String\nparts order before numeric parts, and string parts order lexicographically.\nVersions are implicitly padded with zero parts: when two versions with a\ndifferent number of parts are compared, the shorter one is padded with zeros.\nIt is generally a bad idea to use a versioning scheme with a variable number\nof parts though. Separator characters do not affect ordering.  Some examples:   1.0.0  <  2.0.0  1.0.0  <  1.1.0  1.0.0  <  1.0.1  1  =  1.0  1-0  =  1.0  1.a  <  1.0  (string parts order before numeric parts)  1.0.0.a  <  1.0.0  (string parts order before the implicit zero part)  1.0.a  <  1.0.b  1.0.0-beta.1  <  1.0.0  (string parts order before the implicit zero part)  1.0.0-beta  <  1.0.0-beta.1  (implicit zero orders before 1)  1.0.0-beta.1  <  1.0.0-beta.2  1.2a  <  1.1  (string parts order before numeric parts)   Some of these might be counterintuitive. Unfortunately we cannot have both of\nthe following be true without complicating the comparison rules.   1.0-beta.1  <  1.0 .  1.0  <  1.0.a   Tako implements the first choice, and hence  1.0.a  <  1.0 . To avoid\nconfusion, use a versioning scheme that has a fixed number of parts.",
            "title": "Ordering"
        },
        {
            "location": "/tako-fetch/",
            "text": "tako fetch\n\n\nDownload or update an image.\n\n\nSynopsis\n\n\ntako fetch [--init] [--] <config>...\ntako fetch -h | --help\n\n\n\nDescription\n\n\nThis command takes one or more \nconfig files\n. For every\nprovided config file, it:\n\n\n\n\nDownloads the latest manifest from the remote into the destination directory.\n\n\nDowloads the latest image, if a newer compatible version exists.\n\n\nSymlinks \nlatest\n in the destination directory to the newly downloaded image.\n\n\nRestarts any configured systemd units.\n\n\n\n\nOptions\n\n\n--init\n\n\nIf this option is enabled, Tako checks if \nmanifest\n and \nlatest\n exist in the\ndestination directory. If \nlatest\n points to a valid image, Tako exits\nimmediately without checking for new versions. In other words, Tako performs a\nminimal amount of work while still guaranteeing that an image exists in the\ndestination directory if the command exits successfully.\n\n\nThis option can be used to provision an clean system with an initial image.\nRunning \ntako fetch\n before starting an application that depends on the image\nmanaged by Tako ensures that the image exists when the application starts. When\nTako exits with a zero exit code, the image is guaranteed to exist. However,\nwithout \n--init\n Tako will always download the manifest, and possibly\ndownload a new image, even if an older compatible image exists that could be\nused. This delays application startup, and may prevent startup entirely if\nfetching fails (due to connectivity issues, for instance). With \n--init\n, Tako\nonly performs any work if required to start the dependent application.",
            "title": "tako fetch"
        },
        {
            "location": "/tako-fetch/#tako-fetch",
            "text": "Download or update an image.",
            "title": "tako fetch"
        },
        {
            "location": "/tako-fetch/#synopsis",
            "text": "tako fetch [--init] [--] <config>...\ntako fetch -h | --help",
            "title": "Synopsis"
        },
        {
            "location": "/tako-fetch/#description",
            "text": "This command takes one or more  config files . For every\nprovided config file, it:   Downloads the latest manifest from the remote into the destination directory.  Dowloads the latest image, if a newer compatible version exists.  Symlinks  latest  in the destination directory to the newly downloaded image.  Restarts any configured systemd units.",
            "title": "Description"
        },
        {
            "location": "/tako-fetch/#options",
            "text": "",
            "title": "Options"
        },
        {
            "location": "/tako-fetch/#-init",
            "text": "If this option is enabled, Tako checks if  manifest  and  latest  exist in the\ndestination directory. If  latest  points to a valid image, Tako exits\nimmediately without checking for new versions. In other words, Tako performs a\nminimal amount of work while still guaranteeing that an image exists in the\ndestination directory if the command exits successfully.  This option can be used to provision an clean system with an initial image.\nRunning  tako fetch  before starting an application that depends on the image\nmanaged by Tako ensures that the image exists when the application starts. When\nTako exits with a zero exit code, the image is guaranteed to exist. However,\nwithout  --init  Tako will always download the manifest, and possibly\ndownload a new image, even if an older compatible image exists that could be\nused. This delays application startup, and may prevent startup entirely if\nfetching fails (due to connectivity issues, for instance). With  --init , Tako\nonly performs any work if required to start the dependent application.",
            "title": "--init"
        },
        {
            "location": "/tako-store/",
            "text": "tako store\n\n\nAdd a new image version to a server directory.\n\n\nSynopsis\n\n\ntako store [-k <key> | -f <file>] --output <dir> [--] <image> <version>\ntako store -h | --help\n\n\n\nDescription\n\n\nThis commands adds a new file to the store and updates the manifest. It computes\nthe SHA256 of the \n<image>\n file and copies it into \n<dir>/store\n using the hash\nas filename. Tako then adds an entry to the manifest in \n<dir>\n that specifies\nthat \n<version>\n corresponds to the computed hash. Tako signs the updated\nmanifest with the provided secret key.\n\n\nSee \nVersions\n for information on how Tako treats \n<version>\n. For\nproper ordering, versions should start with a digit: use \n1.0.0\n rather than\n\nv1.0.0\n. The version must not contain spaces.\n\n\n\nThe secret key which is used to sign the manifest can be provided in thee ways:\n\n\n\n\nBy setting the \nTAKO_SECRET_KEY\n environment variable.\n\n\nBy passing the secret key directly on the command line with \n--key\n.\n\n\nBy reading the secret key from a file with \n--key-file\n.\n\n\n\n\nCommand-line options take precedence over the environment variable. A key pair\ncan be generated with \ntako gen-key\n.\n\n\nOptions\n\n\n-k\n \n--key <key>\n\n\nProvide the secret key \n<key>\n directly.\n\n\n-f\n \n--key-file <file>\n\n\nRead the secret key from \n<file>\n.\n\n\n-o\n \n--output <dir>\n\n\nSpecifies the server directory. \n<dir>\n must exist. This must be a path on the\nfile system, uris are not supported. Tako will create \n<dir>/manifest\n and\n\n<dir>/store\n if they do not exist yet.",
            "title": "tako store"
        },
        {
            "location": "/tako-store/#tako-store",
            "text": "Add a new image version to a server directory.",
            "title": "tako store"
        },
        {
            "location": "/tako-store/#synopsis",
            "text": "tako store [-k <key> | -f <file>] --output <dir> [--] <image> <version>\ntako store -h | --help",
            "title": "Synopsis"
        },
        {
            "location": "/tako-store/#description",
            "text": "This commands adds a new file to the store and updates the manifest. It computes\nthe SHA256 of the  <image>  file and copies it into  <dir>/store  using the hash\nas filename. Tako then adds an entry to the manifest in  <dir>  that specifies\nthat  <version>  corresponds to the computed hash. Tako signs the updated\nmanifest with the provided secret key.  See  Versions  for information on how Tako treats  <version> . For\nproper ordering, versions should start with a digit: use  1.0.0  rather than v1.0.0 . The version must not contain spaces.  The secret key which is used to sign the manifest can be provided in thee ways:   By setting the  TAKO_SECRET_KEY  environment variable.  By passing the secret key directly on the command line with  --key .  By reading the secret key from a file with  --key-file .   Command-line options take precedence over the environment variable. A key pair\ncan be generated with  tako gen-key .",
            "title": "Description"
        },
        {
            "location": "/tako-store/#options",
            "text": "",
            "title": "Options"
        },
        {
            "location": "/tako-store/#-k-key-key",
            "text": "Provide the secret key  <key>  directly.",
            "title": "-k --key &lt;key&gt;"
        },
        {
            "location": "/tako-store/#-f-key-file-file",
            "text": "Read the secret key from  <file> .",
            "title": "-f --key-file &lt;file&gt;"
        },
        {
            "location": "/tako-store/#-o-output-dir",
            "text": "Specifies the server directory.  <dir>  must exist. This must be a path on the\nfile system, uris are not supported. Tako will create  <dir>/manifest  and <dir>/store  if they do not exist yet.",
            "title": "-o --output &lt;dir&gt;"
        },
        {
            "location": "/tako-gen-key/",
            "text": "tako gen-key\n\n\nGenerate a key pair for signing manifests.\n\n\nSynopsis\n\n\ntako gen-key\ntako gen-key -h | --help\n\n\n\nDescription\n\n\nThis command generates an \nEd25519\n key pair. Both are printed to\nstdout, base64 encoded. The secret key should be kept in a secure location,\nfor example in a password manager, or in a secret store such as \nVault\n\nif automated signing is desired. Tako avoids writing the secret key to disk:\nthe secret key is not protected by a passphrase (like SSH keys can be), so\nif you do want to store the secret key in a plain file, be sure to use full-disk\nencryption. The public key (the shorter one) should be announced to end users.",
            "title": "tako gen-key"
        },
        {
            "location": "/tako-gen-key/#tako-gen-key",
            "text": "Generate a key pair for signing manifests.",
            "title": "tako gen-key"
        },
        {
            "location": "/tako-gen-key/#synopsis",
            "text": "tako gen-key\ntako gen-key -h | --help",
            "title": "Synopsis"
        },
        {
            "location": "/tako-gen-key/#description",
            "text": "This command generates an  Ed25519  key pair. Both are printed to\nstdout, base64 encoded. The secret key should be kept in a secure location,\nfor example in a password manager, or in a secret store such as  Vault \nif automated signing is desired. Tako avoids writing the secret key to disk:\nthe secret key is not protected by a passphrase (like SSH keys can be), so\nif you do want to store the secret key in a plain file, be sure to use full-disk\nencryption. The public key (the shorter one) should be announced to end users.",
            "title": "Description"
        },
        {
            "location": "/manifest-format/",
            "text": "Manifest Format\n\n\nThe manifest lists all available image versions and their SHA256 hashes.\nThe format is human-readable for convenience.\n\n\nStructure\n\n\nThe manifest starts with a line \nTako Manifest 1\n that identifies the file as\na manifest.\n\n\nAfter the header is a blank line. Then follows one image version per line,\nformatted as the version number, a space, and the hexadecimally encoded SHA256\nof the image. This makes it easy to use \nsha256sum\n as a sanity check. Versions\nare sorted by version number.\n\n\nAfter the image versions is again a blank line, followed by the base64-encoded\nEd25519 signature of all of the preceding content (including newlines).\n\n\nNewlines are a single line feed (\n\\n\n). Version numbers should be ascii. Hence\nthe entire file is valid ascii, and also valid UTF-8.\n\n\nExample\n\n\nTako Manifest 1\n\n1.0.0 b101acf3c4870594bb4363090d5ab966c193fb329e2f2db2096708e08c4913e2\n1.1.0 9641a49d02e90cbb6213f202fb632da70cdc59073d42283cfcdc1d786454f17f\n2.0.0 b7b01c6f6772529c66b945e559cb1f46546ef62063e44c1d1068725157ae1cda\n\nfQK92C/tPnH0uqxrTEnU+LEE4jnSpQPbOItph4kGAEfWEmn6wPXiQsSdXlDmoneaJkG6KLvInTvB7FlELoeQFg==\n\n\n\nRationale\n\n\nThe manifest format is inspired by the well-established practice of distributing\na GPG-signed \nSHASUMS\n file.\n\n\n\n\nWe include a version line, so future versions of Tako can still read older\n  manifests.\n\n\nThe signature is embedded, rather than external, to avoid race conditions when\n  uploading a new manifest to the server. One would still need to upload new\n  images before uploading a new manifest.\n\n\nThe signature is an Ed25519 signature rather than a GPG signature, because GPG\n  involves a stateful trust store that is difficult to provision in an automated\n  way. In practice people use GPG is only for signature verification. For\n  authentication, rather than relying on GPG\u2019s web of trust, people announce\n  the fingerprint of their key in a trusted location (Twitter, Github, an https-\n  protected website). Ed25519 public keys are small enough that the full public\n  key can be announced in places where we would normally announce a fingerprint.\n\n\nThe manifest does not include timestamps, to ensure that it is reproducible.\n  Timestamps belong in a changelog or audit log.\n\n\nEntries should never be removed from the manifest. There are reasons to stop\n  providing an image (for instance because it contained a critical bug that\n  causes data loss). In that case the image itself can be removed from the\n  server, but it should still be listed in the manifest. This prevents\n  accidentally releasing different images under the same version number. It also\n  ensures that clients which did download the image can still identify it, so\n  they do not end up running a mysterous image without record of existence.",
            "title": "Manifest Format"
        },
        {
            "location": "/manifest-format/#manifest-format",
            "text": "The manifest lists all available image versions and their SHA256 hashes.\nThe format is human-readable for convenience.",
            "title": "Manifest Format"
        },
        {
            "location": "/manifest-format/#structure",
            "text": "The manifest starts with a line  Tako Manifest 1  that identifies the file as\na manifest.  After the header is a blank line. Then follows one image version per line,\nformatted as the version number, a space, and the hexadecimally encoded SHA256\nof the image. This makes it easy to use  sha256sum  as a sanity check. Versions\nare sorted by version number.  After the image versions is again a blank line, followed by the base64-encoded\nEd25519 signature of all of the preceding content (including newlines).  Newlines are a single line feed ( \\n ). Version numbers should be ascii. Hence\nthe entire file is valid ascii, and also valid UTF-8.",
            "title": "Structure"
        },
        {
            "location": "/manifest-format/#example",
            "text": "Tako Manifest 1\n\n1.0.0 b101acf3c4870594bb4363090d5ab966c193fb329e2f2db2096708e08c4913e2\n1.1.0 9641a49d02e90cbb6213f202fb632da70cdc59073d42283cfcdc1d786454f17f\n2.0.0 b7b01c6f6772529c66b945e559cb1f46546ef62063e44c1d1068725157ae1cda\n\nfQK92C/tPnH0uqxrTEnU+LEE4jnSpQPbOItph4kGAEfWEmn6wPXiQsSdXlDmoneaJkG6KLvInTvB7FlELoeQFg==",
            "title": "Example"
        },
        {
            "location": "/manifest-format/#rationale",
            "text": "The manifest format is inspired by the well-established practice of distributing\na GPG-signed  SHASUMS  file.   We include a version line, so future versions of Tako can still read older\n  manifests.  The signature is embedded, rather than external, to avoid race conditions when\n  uploading a new manifest to the server. One would still need to upload new\n  images before uploading a new manifest.  The signature is an Ed25519 signature rather than a GPG signature, because GPG\n  involves a stateful trust store that is difficult to provision in an automated\n  way. In practice people use GPG is only for signature verification. For\n  authentication, rather than relying on GPG\u2019s web of trust, people announce\n  the fingerprint of their key in a trusted location (Twitter, Github, an https-\n  protected website). Ed25519 public keys are small enough that the full public\n  key can be announced in places where we would normally announce a fingerprint.  The manifest does not include timestamps, to ensure that it is reproducible.\n  Timestamps belong in a changelog or audit log.  Entries should never be removed from the manifest. There are reasons to stop\n  providing an image (for instance because it contained a critical bug that\n  causes data loss). In that case the image itself can be removed from the\n  server, but it should still be listed in the manifest. This prevents\n  accidentally releasing different images under the same version number. It also\n  ensures that clients which did download the image can still identify it, so\n  they do not end up running a mysterous image without record of existence.",
            "title": "Rationale"
        }
    ]
}