{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tako Tako securely downloads and updates binary files such as container images. It is intended as a lightweight delivery mechanism for signed versioned images. Through version bounds Tako enables automatic security updates while avoiding breaking changes. Ed25519 signatures ensure that images come from a trusted source. Tako is a short-lived process that downloads images specified in its configuration and then exits. Optionally Tako restarts configured systemd units when it downloads a newer version of an image. Tako runs on two occasions: Periodically, triggered by a systemd timer. Tako checks for new compatible versions of a configured image. If one exists, Tako downloads it and restarts the systemd unit that uses the image. As a dependency of the systemd unit that uses the image, to provision a clean system with an initial image. Tako is a single binary with minimal dependencies (libc and libcurl only), because Tako is used to bootstrap more complex applications. Installing Tako is as easy as copying over the binary. User Guide Downloading Images Distributing Images Configuration Versions Reference tako fetch tako store tako gen-key Internals Manifest Format","title":"Overview"},{"location":"#tako","text":"Tako securely downloads and updates binary files such as container images. It is intended as a lightweight delivery mechanism for signed versioned images. Through version bounds Tako enables automatic security updates while avoiding breaking changes. Ed25519 signatures ensure that images come from a trusted source. Tako is a short-lived process that downloads images specified in its configuration and then exits. Optionally Tako restarts configured systemd units when it downloads a newer version of an image. Tako runs on two occasions: Periodically, triggered by a systemd timer. Tako checks for new compatible versions of a configured image. If one exists, Tako downloads it and restarts the systemd unit that uses the image. As a dependency of the systemd unit that uses the image, to provision a clean system with an initial image. Tako is a single binary with minimal dependencies (libc and libcurl only), because Tako is used to bootstrap more complex applications. Installing Tako is as easy as copying over the binary.","title":"Tako"},{"location":"#user-guide","text":"Downloading Images Distributing Images Configuration Versions","title":"User Guide"},{"location":"#reference","text":"tako fetch tako store tako gen-key","title":"Reference"},{"location":"#internals","text":"Manifest Format","title":"Internals"},{"location":"configuration/","text":"Configuration Tako determines what to fetch and where to store images from a config file, one per image. Config files follow the same syntax as systemd unit files. Example Origin=https://images.example.com/app-foo PublicKey=8+r5DKNN/cwI+h0oHxMtgdyND3S/5xDLHQu0hFUmq+g= Destination=/var/lib/images/app-foo Version=1.* # Restart app-foo after a new image has been fetched. Restart=app-foo.service Options The following options are available. Unless noted otherwise, all options must be specified exactly once. Origin= Remote uri to fetch the manifest and images from. Usually an https url, but anything supported by Curl will do, such as a file:// or ssh:// uri. The uri must point to a directory that contains a manifest file. A trailing slash is allowed, but not required. PublicKey= Public key used to verify image integrity and authenthicity. The public key should be announced by the distributor of the image. Distributors can generate a key pair with tako gen-key . Destination= Directory where images will be stored. This directory must exist. Tako will create a store subdirectory to hold images, a manifest file which is a copy of the remote manifest, and a latest symlink that points to the latest compatible image in the store. A trailing slash is allowed, but not required. Version= A version pattern that indicates which version range is compatible. Tako will fetch the latest (highest numbered) compatible version. The version pattern can be a fixed version, a wildcard pattern, or a bounds pattern. See Versions for more information. Restart= A systemd unit to restart in case a newer image has been fetched. The format is the same as that of Requires= in systemd units. This option may be specified more than once, or multiple space-separated units may be specified in one option. This option is not required: if it is not set, no unit will be restarted. Comments Like systemd unit files, lines starting with # or ; are ignored. Empty lines are ignored as well.","title":"Configuration"},{"location":"configuration/#configuration","text":"Tako determines what to fetch and where to store images from a config file, one per image. Config files follow the same syntax as systemd unit files.","title":"Configuration"},{"location":"configuration/#example","text":"Origin=https://images.example.com/app-foo PublicKey=8+r5DKNN/cwI+h0oHxMtgdyND3S/5xDLHQu0hFUmq+g= Destination=/var/lib/images/app-foo Version=1.* # Restart app-foo after a new image has been fetched. Restart=app-foo.service","title":"Example"},{"location":"configuration/#options","text":"The following options are available. Unless noted otherwise, all options must be specified exactly once.","title":"Options"},{"location":"configuration/#origin","text":"Remote uri to fetch the manifest and images from. Usually an https url, but anything supported by Curl will do, such as a file:// or ssh:// uri. The uri must point to a directory that contains a manifest file. A trailing slash is allowed, but not required.","title":"Origin="},{"location":"configuration/#publickey","text":"Public key used to verify image integrity and authenthicity. The public key should be announced by the distributor of the image. Distributors can generate a key pair with tako gen-key .","title":"PublicKey="},{"location":"configuration/#destination","text":"Directory where images will be stored. This directory must exist. Tako will create a store subdirectory to hold images, a manifest file which is a copy of the remote manifest, and a latest symlink that points to the latest compatible image in the store. A trailing slash is allowed, but not required.","title":"Destination="},{"location":"configuration/#version","text":"A version pattern that indicates which version range is compatible. Tako will fetch the latest (highest numbered) compatible version. The version pattern can be a fixed version, a wildcard pattern, or a bounds pattern. See Versions for more information.","title":"Version="},{"location":"configuration/#restart","text":"A systemd unit to restart in case a newer image has been fetched. The format is the same as that of Requires= in systemd units. This option may be specified more than once, or multiple space-separated units may be specified in one option. This option is not required: if it is not set, no unit will be restarted.","title":"Restart="},{"location":"configuration/#comments","text":"Like systemd unit files, lines starting with # or ; are ignored. Empty lines are ignored as well.","title":"Comments"},{"location":"distributing-images/","text":"Distributing Images A Tako server is a regular http server, with a particular directory layout. The origin uri points to a directory that contains the manifest file and the image store. manifest is a file that lists all available versions and their SHA256 digests. The manifest is signed. See Manifest Format for more information about the manifest format. store is a directory that contains all images. Files are named after their digest. Images can be added to the directory with tako store . The most convenient way to maintain the server directory is to have a local copy that Tako can act on, and to sync that to a server. Immutable Images Tako is designed as an append-only system where images are immutable. Changing an image is not possible: publish it as a new version instead. The Tako client tako fetch stores a copy of the manifest locally, and when it downloads a new version of the manifest, it must be a superset of the local manifest. If the hash of a particular version has changed in the remote manifest, or if a version was removed, the client rejects the new manifest, even if it has a valid signature. In some occasions, it might be necessary to remove a previously published image. To do so, simply stop serving the image by removing it from the store directory. The manifest will still list the image. If a client selects that particular image as a candidate to download, the tako fetch will fail. This is generally not an issue if a newer compatible version is available. If this is not the case, you can configure the server to serve \u201c410 Gone\u201d on the url of the removed image. In the future \u2014 the following has not yet been implemented \u2014 if tako fetch encounters a 410 it will not fail, but instead select an earlier compatible version and try again.","title":"Distributing Images"},{"location":"distributing-images/#distributing-images","text":"A Tako server is a regular http server, with a particular directory layout. The origin uri points to a directory that contains the manifest file and the image store. manifest is a file that lists all available versions and their SHA256 digests. The manifest is signed. See Manifest Format for more information about the manifest format. store is a directory that contains all images. Files are named after their digest. Images can be added to the directory with tako store . The most convenient way to maintain the server directory is to have a local copy that Tako can act on, and to sync that to a server.","title":"Distributing Images"},{"location":"distributing-images/#immutable-images","text":"Tako is designed as an append-only system where images are immutable. Changing an image is not possible: publish it as a new version instead. The Tako client tako fetch stores a copy of the manifest locally, and when it downloads a new version of the manifest, it must be a superset of the local manifest. If the hash of a particular version has changed in the remote manifest, or if a version was removed, the client rejects the new manifest, even if it has a valid signature. In some occasions, it might be necessary to remove a previously published image. To do so, simply stop serving the image by removing it from the store directory. The manifest will still list the image. If a client selects that particular image as a candidate to download, the tako fetch will fail. This is generally not an issue if a newer compatible version is available. If this is not the case, you can configure the server to serve \u201c410 Gone\u201d on the url of the removed image. In the future \u2014 the following has not yet been implemented \u2014 if tako fetch encounters a 410 it will not fail, but instead select an earlier compatible version and try again.","title":"Immutable Images"},{"location":"downloading-images/","text":"Downloading Images To download images with Tako, the image distributor should have provided you with two things: A remote url, such as https://images.example.com/app-foo . A public key, such as l0D28J2fiIXvWPbeZP7wkaq+dB55Gl2ysigl9mQH29k= . The next step is to create a configuration file to tell Tako what to fetch from that remote, and where to store it. For example, write the following to example.tako : Origin=https://images.example.com/app-foo PublicKey=l0D28J2fiIXvWPbeZP7wkaq+dB55Gl2ysigl9mQH29k= Destination=/tmp/app-foo Version=* Download the latest available image with tako fetch example.tako . Now /tmp/app-foo/latest is a symlink to the latest image, which itself is stored as a readonly file in /tmp/app-foo/store . Local Store Tako downloads images into a destination directory. It creates the following files there: store/<hexdigest> # Readonly raw image files. manifest # A copy of the manifest served by the origin. latest # Symlink to the latest image. The store keeps older versions to allow quick rollbacks. In the future Tako will be able to prune older versions if the store exceeds a certain size. Automating Updates To use Tako to keep the image up to date, run Tako periodically, for example using a systemd timer . Using RandomizedDelaySec= is recommended to avoid overloading the remote server. Initial Provisioning Tako can be used to acquire an initial image. For example, you can run tako fetch through ExecStartPre= with systemd. In this case, downloading the latest manifest and possibly downloading a new image, may incur an unacceptable startup delay. In this case the --init flag can be used to skip network access if a valid manifest and image already exist.","title":"Downloading Images"},{"location":"downloading-images/#downloading-images","text":"To download images with Tako, the image distributor should have provided you with two things: A remote url, such as https://images.example.com/app-foo . A public key, such as l0D28J2fiIXvWPbeZP7wkaq+dB55Gl2ysigl9mQH29k= . The next step is to create a configuration file to tell Tako what to fetch from that remote, and where to store it. For example, write the following to example.tako : Origin=https://images.example.com/app-foo PublicKey=l0D28J2fiIXvWPbeZP7wkaq+dB55Gl2ysigl9mQH29k= Destination=/tmp/app-foo Version=* Download the latest available image with tako fetch example.tako . Now /tmp/app-foo/latest is a symlink to the latest image, which itself is stored as a readonly file in /tmp/app-foo/store .","title":"Downloading Images"},{"location":"downloading-images/#local-store","text":"Tako downloads images into a destination directory. It creates the following files there: store/<hexdigest> # Readonly raw image files. manifest # A copy of the manifest served by the origin. latest # Symlink to the latest image. The store keeps older versions to allow quick rollbacks. In the future Tako will be able to prune older versions if the store exceeds a certain size.","title":"Local Store"},{"location":"downloading-images/#automating-updates","text":"To use Tako to keep the image up to date, run Tako periodically, for example using a systemd timer . Using RandomizedDelaySec= is recommended to avoid overloading the remote server.","title":"Automating Updates"},{"location":"downloading-images/#initial-provisioning","text":"Tako can be used to acquire an initial image. For example, you can run tako fetch through ExecStartPre= with systemd. In this case, downloading the latest manifest and possibly downloading a new image, may incur an unacceptable startup delay. In this case the --init flag can be used to skip network access if a valid manifest and image already exist.","title":"Initial Provisioning"},{"location":"manifest-format/","text":"Manifest Format The manifest lists all available image versions and their SHA256 hashes. The format is human-readable for convenience. Structure The manifest starts with a line Tako Manifest 1 that identifies the file as a manifest. After the header is a blank line. Then follows one image version per line, formatted as the version number, a space, the file size in bytes, a space, and the hexadecimally encoded SHA256 of the image. This makes it easy to use sha256sum as a sanity check. Versions are sorted by version number. After the image versions is again a blank line, followed by the base64-encoded Ed25519 signature of all of the preceding content (including newlines). Newlines are a single line feed ( \\n ). Version numbers should be ascii. Hence the entire file is valid ascii, and also valid UTF-8. Example Tako Manifest 1 1.0.0 10092569 b101acf3c4870594bb4363090d5ab966c193fb329e2f2db2096708e08c4913e2 1.1.0 11239411 9641a49d02e90cbb6213f202fb632da70cdc59073d42283cfcdc1d786454f17f 2.0.0 11862029 b7b01c6f6772529c66b945e559cb1f46546ef62063e44c1d1068725157ae1cda fQK92C/tPnH0uqxrTEnU+LEE4jnSpQPbOItph4kGAEfWEmn6wPXiQsSdXlDmoneaJkG6KLvInTvB7FlELoeQFg== Rationale The manifest format is inspired by the well-established practice of distributing a GPG-signed SHASUMS file. We include a version line, so future versions of Tako can still read older manifests. The signature is embedded, rather than external, to avoid race conditions when uploading a new manifest to the server. One would still need to upload new images before uploading a new manifest. The signature is an Ed25519 signature rather than a GPG signature, because GPG involves a stateful trust store that is difficult to provision in an automated way. In practice people use GPG only for signature verification. For authentication, rather than relying on GPG\u2019s web of trust, people announce the fingerprint of their key in a trusted location (Twitter, Github, an https- protected website). Ed25519 public keys are small enough that the full public key can be announced in places where we would normally announce a fingerprint. The manifest does not include timestamps, to ensure that it is reproducible. Timestamps belong in a changelog or audit log. Entries should never be removed from the manifest. There are reasons to stop providing an image (for instance because it contained a critical bug that causes data loss). In that case the image itself can be removed from the server, but it should still be listed in the manifest. This prevents accidentally releasing different images under the same version number. It also ensures that clients which did download the image can still identify it, so they do not end up running a mysterous image without record of existence. The size of each image is included (and therefore signed) so malicious mirrors cannot cause clients to download large files that would fill up their disks.","title":"Manifest Format"},{"location":"manifest-format/#manifest-format","text":"The manifest lists all available image versions and their SHA256 hashes. The format is human-readable for convenience.","title":"Manifest Format"},{"location":"manifest-format/#structure","text":"The manifest starts with a line Tako Manifest 1 that identifies the file as a manifest. After the header is a blank line. Then follows one image version per line, formatted as the version number, a space, the file size in bytes, a space, and the hexadecimally encoded SHA256 of the image. This makes it easy to use sha256sum as a sanity check. Versions are sorted by version number. After the image versions is again a blank line, followed by the base64-encoded Ed25519 signature of all of the preceding content (including newlines). Newlines are a single line feed ( \\n ). Version numbers should be ascii. Hence the entire file is valid ascii, and also valid UTF-8.","title":"Structure"},{"location":"manifest-format/#example","text":"Tako Manifest 1 1.0.0 10092569 b101acf3c4870594bb4363090d5ab966c193fb329e2f2db2096708e08c4913e2 1.1.0 11239411 9641a49d02e90cbb6213f202fb632da70cdc59073d42283cfcdc1d786454f17f 2.0.0 11862029 b7b01c6f6772529c66b945e559cb1f46546ef62063e44c1d1068725157ae1cda fQK92C/tPnH0uqxrTEnU+LEE4jnSpQPbOItph4kGAEfWEmn6wPXiQsSdXlDmoneaJkG6KLvInTvB7FlELoeQFg==","title":"Example"},{"location":"manifest-format/#rationale","text":"The manifest format is inspired by the well-established practice of distributing a GPG-signed SHASUMS file. We include a version line, so future versions of Tako can still read older manifests. The signature is embedded, rather than external, to avoid race conditions when uploading a new manifest to the server. One would still need to upload new images before uploading a new manifest. The signature is an Ed25519 signature rather than a GPG signature, because GPG involves a stateful trust store that is difficult to provision in an automated way. In practice people use GPG only for signature verification. For authentication, rather than relying on GPG\u2019s web of trust, people announce the fingerprint of their key in a trusted location (Twitter, Github, an https- protected website). Ed25519 public keys are small enough that the full public key can be announced in places where we would normally announce a fingerprint. The manifest does not include timestamps, to ensure that it is reproducible. Timestamps belong in a changelog or audit log. Entries should never be removed from the manifest. There are reasons to stop providing an image (for instance because it contained a critical bug that causes data loss). In that case the image itself can be removed from the server, but it should still be listed in the manifest. This prevents accidentally releasing different images under the same version number. It also ensures that clients which did download the image can still identify it, so they do not end up running a mysterous image without record of existence. The size of each image is included (and therefore signed) so malicious mirrors cannot cause clients to download large files that would fill up their disks.","title":"Rationale"},{"location":"tako-fetch/","text":"tako fetch Download or update an image. Synopsis tako fetch [--init] [--] <config>... tako fetch -h | --help Description This command takes one or more config files . For every provided config file, it: Downloads the latest manifest from the remote into the destination directory. Downloads the latest image, if a newer compatible version exists. Symlinks latest in the destination directory to the newly downloaded image. Restarts any configured systemd units. Options --init If this option is enabled, Tako checks if manifest and latest exist in the destination directory. If latest points to a valid image, Tako exits immediately without checking for new versions. In other words, Tako performs a minimal amount of work while still guaranteeing that an image exists in the destination directory if the command exits successfully. This option can be used to provision an clean system with an initial image. Running tako fetch before starting an application that depends on the image managed by Tako ensures that the image exists when the application starts. When Tako exits with a zero exit code, the image is guaranteed to exist. However, without --init Tako will always download the manifest, and possibly download a new image, even if an older compatible image exists that could be used. This delays application startup, and may prevent startup entirely if fetching fails (due to connectivity issues, for instance). With --init , Tako only performs any work if required to start the dependent application.","title":"tako fetch"},{"location":"tako-fetch/#tako-fetch","text":"Download or update an image.","title":"tako fetch"},{"location":"tako-fetch/#synopsis","text":"tako fetch [--init] [--] <config>... tako fetch -h | --help","title":"Synopsis"},{"location":"tako-fetch/#description","text":"This command takes one or more config files . For every provided config file, it: Downloads the latest manifest from the remote into the destination directory. Downloads the latest image, if a newer compatible version exists. Symlinks latest in the destination directory to the newly downloaded image. Restarts any configured systemd units.","title":"Description"},{"location":"tako-fetch/#options","text":"","title":"Options"},{"location":"tako-fetch/#-init","text":"If this option is enabled, Tako checks if manifest and latest exist in the destination directory. If latest points to a valid image, Tako exits immediately without checking for new versions. In other words, Tako performs a minimal amount of work while still guaranteeing that an image exists in the destination directory if the command exits successfully. This option can be used to provision an clean system with an initial image. Running tako fetch before starting an application that depends on the image managed by Tako ensures that the image exists when the application starts. When Tako exits with a zero exit code, the image is guaranteed to exist. However, without --init Tako will always download the manifest, and possibly download a new image, even if an older compatible image exists that could be used. This delays application startup, and may prevent startup entirely if fetching fails (due to connectivity issues, for instance). With --init , Tako only performs any work if required to start the dependent application.","title":"--init"},{"location":"tako-gen-key/","text":"tako gen-key Generate a key pair for signing manifests. Synopsis tako gen-key tako gen-key -h | --help Description This command generates an Ed25519 key pair. Both are printed to stdout, base64 encoded. The secret key should be kept in a secure location, for example in a password manager, or in a secret store such as Vault if automated signing is desired. Tako avoids writing the secret key to disk: the secret key is not protected by a passphrase (like SSH keys can be), so if you do want to store the secret key in a plain file, be sure to use full-disk encryption. The public key (the shorter one) should be announced to end users. The secret key is prefixed with SECRET+ , to reduce the risk of mistaking the secret key for public data. The prefix is part of the key, it must always be included.","title":"tako gen-key"},{"location":"tako-gen-key/#tako-gen-key","text":"Generate a key pair for signing manifests.","title":"tako gen-key"},{"location":"tako-gen-key/#synopsis","text":"tako gen-key tako gen-key -h | --help","title":"Synopsis"},{"location":"tako-gen-key/#description","text":"This command generates an Ed25519 key pair. Both are printed to stdout, base64 encoded. The secret key should be kept in a secure location, for example in a password manager, or in a secret store such as Vault if automated signing is desired. Tako avoids writing the secret key to disk: the secret key is not protected by a passphrase (like SSH keys can be), so if you do want to store the secret key in a plain file, be sure to use full-disk encryption. The public key (the shorter one) should be announced to end users. The secret key is prefixed with SECRET+ , to reduce the risk of mistaking the secret key for public data. The prefix is part of the key, it must always be included.","title":"Description"},{"location":"tako-store/","text":"tako store Add a new image version to a server directory. Synopsis tako store [-k <key> | -f <file>] --output <dir> [--] <image> <version> tako store -h | --help Description This commands adds a new file to the store and updates the manifest. It computes the SHA256 of the <image> file and copies it into <dir>/store using the hash as filename. Tako then adds an entry to the manifest in <dir> that specifies that <version> corresponds to the computed hash. Tako signs the updated manifest with the provided secret key. See Versions for information on how Tako treats <version> . For proper ordering, versions should start with a digit: use 1.0.0 rather than v1.0.0 . The version must not contain spaces. The secret key which is used to sign the manifest can be provided in thee ways: By setting the TAKO_SECRET_KEY environment variable. By passing the secret key directly on the command line with --key . By reading the secret key from a file with --key-file . Command-line options take precedence over the environment variable. A key pair can be generated with tako gen-key . Options -k --key <key> Provide the secret key <key> directly. -f --key-file <file> Read the secret key from <file> . -o --output <dir> Specifies the server directory. <dir> must exist. This must be a path on the file system, uris are not supported. Tako will create <dir>/manifest and <dir>/store if they do not exist yet.","title":"tako store"},{"location":"tako-store/#tako-store","text":"Add a new image version to a server directory.","title":"tako store"},{"location":"tako-store/#synopsis","text":"tako store [-k <key> | -f <file>] --output <dir> [--] <image> <version> tako store -h | --help","title":"Synopsis"},{"location":"tako-store/#description","text":"This commands adds a new file to the store and updates the manifest. It computes the SHA256 of the <image> file and copies it into <dir>/store using the hash as filename. Tako then adds an entry to the manifest in <dir> that specifies that <version> corresponds to the computed hash. Tako signs the updated manifest with the provided secret key. See Versions for information on how Tako treats <version> . For proper ordering, versions should start with a digit: use 1.0.0 rather than v1.0.0 . The version must not contain spaces. The secret key which is used to sign the manifest can be provided in thee ways: By setting the TAKO_SECRET_KEY environment variable. By passing the secret key directly on the command line with --key . By reading the secret key from a file with --key-file . Command-line options take precedence over the environment variable. A key pair can be generated with tako gen-key .","title":"Description"},{"location":"tako-store/#options","text":"","title":"Options"},{"location":"tako-store/#-k-key-ltkeygt","text":"Provide the secret key <key> directly.","title":"-k --key &lt;key&gt;"},{"location":"tako-store/#-f-key-file-ltfilegt","text":"Read the secret key from <file> .","title":"-f --key-file &lt;file&gt;"},{"location":"tako-store/#-o-output-ltdirgt","text":"Specifies the server directory. <dir> must exist. This must be a path on the file system, uris are not supported. Tako will create <dir>/manifest and <dir>/store if they do not exist yet.","title":"-o --output &lt;dir&gt;"},{"location":"versions/","text":"Versions Tako does not enforce any particular versioning scheme. Instead it implements a simple version parser and constraint resolver that is compatible with most versioning schemes, such as Semantic Versioning . Patterns Compatible versions are selected by matching versions against a pattern. A pattern is either a wildcard pattern or a bounds pattern . A wildcard pattern is a version that may end in * . A bounds pattern specifies an inclusive lower bound and an exclusive upper bound separated by <= v < . Some examples: * matches any version. 1.* matches 1.0 , 1.1 , 1.2 , etc., but not 2.0 , or 0.1 . It does match 1 and 1.0.0 , which are both equivalent to 1.0 . 1.13.7 matches 1.13.7 . It also matches 1.13.7.0 , 1.13.7.0.0 , etc., which are equivalent to 1.13.7 . Such a pattern can be used for version pinning. 1.0 <= v < 2.0 is the same as 1.* . 2.3 <= v < 3.0 matches versions that are semver-compatible with 2.3. Syntax Versions consist of parts separated by separators . A part is either numeric or a string. A numeric part is an unsigned integer. A separator is one of . , - , and _ . Versions map to a list of parts. Some examples: 1.0.0 \u21d2 [1, 0, 0] 1.0.0-beta \u21d2 [1, 0, 0, \"beta\"] 1.0.0-beta-25856-ge63d979e22 \u21d2 [1, 1, 0, \"beta\", 25856, \"ge63d979e22\"] 1.0.0-beta.2 \u21d2 [1, 0, 0, \"beta\", 2] 1.1.0.h-1 \u21d2 [1, 1, 0, \"h\", 1] 66.0.3359.117-1 \u21d2 [66, 0, 3359, 117, 1] 1.2a \u21d2 [1, \"2a\"] Ordering Versions are ordered conventionally. They are compared part by part. String parts order before numeric parts, and string parts order lexicographically. Versions are implicitly padded with zero parts: when two versions with a different number of parts are compared, the shorter one is padded with zeros. It is generally a bad idea to use a versioning scheme with a variable number of parts though. Separator characters do not affect ordering. Some examples: 1.0.0 < 2.0.0 1.0.0 < 1.1.0 1.0.0 < 1.0.1 1 = 1.0 1-0 = 1.0 1.a < 1.0 (string parts order before numeric parts) 1.0.0.a < 1.0.0 (string parts order before the implicit zero part) 1.0.a < 1.0.b 1.0.0-beta.1 < 1.0.0 (string parts order before the implicit zero part) 1.0.0-beta < 1.0.0-beta.1 (implicit zero orders before 1) 1.0.0-beta.1 < 1.0.0-beta.2 1.2a < 1.1 (string parts order before numeric parts) Some of these might be counterintuitive. Unfortunately we cannot have both of the following be true without complicating the comparison rules. 1.0-beta.1 < 1.0 . 1.0 < 1.0.a Tako implements the first choice, and hence 1.0.a < 1.0 . To avoid confusion, use a versioning scheme that has a fixed number of parts.","title":"Versions"},{"location":"versions/#versions","text":"Tako does not enforce any particular versioning scheme. Instead it implements a simple version parser and constraint resolver that is compatible with most versioning schemes, such as Semantic Versioning .","title":"Versions"},{"location":"versions/#patterns","text":"Compatible versions are selected by matching versions against a pattern. A pattern is either a wildcard pattern or a bounds pattern . A wildcard pattern is a version that may end in * . A bounds pattern specifies an inclusive lower bound and an exclusive upper bound separated by <= v < . Some examples: * matches any version. 1.* matches 1.0 , 1.1 , 1.2 , etc., but not 2.0 , or 0.1 . It does match 1 and 1.0.0 , which are both equivalent to 1.0 . 1.13.7 matches 1.13.7 . It also matches 1.13.7.0 , 1.13.7.0.0 , etc., which are equivalent to 1.13.7 . Such a pattern can be used for version pinning. 1.0 <= v < 2.0 is the same as 1.* . 2.3 <= v < 3.0 matches versions that are semver-compatible with 2.3.","title":"Patterns"},{"location":"versions/#syntax","text":"Versions consist of parts separated by separators . A part is either numeric or a string. A numeric part is an unsigned integer. A separator is one of . , - , and _ . Versions map to a list of parts. Some examples: 1.0.0 \u21d2 [1, 0, 0] 1.0.0-beta \u21d2 [1, 0, 0, \"beta\"] 1.0.0-beta-25856-ge63d979e22 \u21d2 [1, 1, 0, \"beta\", 25856, \"ge63d979e22\"] 1.0.0-beta.2 \u21d2 [1, 0, 0, \"beta\", 2] 1.1.0.h-1 \u21d2 [1, 1, 0, \"h\", 1] 66.0.3359.117-1 \u21d2 [66, 0, 3359, 117, 1] 1.2a \u21d2 [1, \"2a\"]","title":"Syntax"},{"location":"versions/#ordering","text":"Versions are ordered conventionally. They are compared part by part. String parts order before numeric parts, and string parts order lexicographically. Versions are implicitly padded with zero parts: when two versions with a different number of parts are compared, the shorter one is padded with zeros. It is generally a bad idea to use a versioning scheme with a variable number of parts though. Separator characters do not affect ordering. Some examples: 1.0.0 < 2.0.0 1.0.0 < 1.1.0 1.0.0 < 1.0.1 1 = 1.0 1-0 = 1.0 1.a < 1.0 (string parts order before numeric parts) 1.0.0.a < 1.0.0 (string parts order before the implicit zero part) 1.0.a < 1.0.b 1.0.0-beta.1 < 1.0.0 (string parts order before the implicit zero part) 1.0.0-beta < 1.0.0-beta.1 (implicit zero orders before 1) 1.0.0-beta.1 < 1.0.0-beta.2 1.2a < 1.1 (string parts order before numeric parts) Some of these might be counterintuitive. Unfortunately we cannot have both of the following be true without complicating the comparison rules. 1.0-beta.1 < 1.0 . 1.0 < 1.0.a Tako implements the first choice, and hence 1.0.a < 1.0 . To avoid confusion, use a versioning scheme that has a fixed number of parts.","title":"Ordering"},{"location":"README.theme/","text":"Kilsbergen A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more. Demos Tako documentation Pris documentation Features Responsive design Zero javascript License Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"Kilsbergen"},{"location":"README.theme/#kilsbergen","text":"A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more.","title":"Kilsbergen"},{"location":"README.theme/#demos","text":"Tako documentation Pris documentation","title":"Demos"},{"location":"README.theme/#features","text":"Responsive design Zero javascript","title":"Features"},{"location":"README.theme/#license","text":"Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"License"}]}